// Generated by CoffeeScript 1.10.0
(function() {
  var Monomial, Polynomial, Term, allSPolynomials, basisOfQuotient, computeGrobnerBasis, concat, doSequentially, gcd, getValue, indices, latticePointUnder, main, onclick, println, setDisable, setEnable, setValue, sortBy, variables,
    slice = [].slice;

  variables = [];

  Term = (function() {
    function Term(degrees) {
      this.degrees = degrees;
    }

    Term.prototype.toString = function() {
      if (this.isOne()) {
        return "1";
      } else {
        return indices(variables).filter((function(_this) {
          return function(i) {
            return _this.degrees[i] !== 0;
          };
        })(this)).map((function(_this) {
          return function(i) {
            if (_this.degrees[i] === 1) {
              return "" + variables[i];
            } else {
              return variables[i] + "^" + _this.degrees[i];
            }
          };
        })(this)).join(" ");
      }
    };

    Term.prototype.isOne = function() {
      return indices(variables).every((function(_this) {
        return function(i) {
          return _this.degrees[i] === 0;
        };
      })(this));
    };

    Term.prototype.totalDegree = function() {
      return this.degrees.reduce(((function(_this) {
        return function(x, y) {
          return x + y;
        };
      })(this)), 0);
    };

    Term.prototype.equals = function(that) {
      return indices(variables).every((function(_this) {
        return function(i) {
          return _this.degrees[i] === that.degrees[i];
        };
      })(this));
    };

    Term.prototype.divides = function(that) {
      return indices(variables).every((function(_this) {
        return function(i) {
          return _this.degrees[i] <= that.degrees[i];
        };
      })(this));
    };

    Term.prototype.lessThan = function(that) {
      var i, k, len1, ref, that_deg, this_deg;
      this_deg = this.totalDegree();
      that_deg = that.totalDegree();
      if (this_deg < that_deg) {
        return true;
      }
      if (this_deg > that_deg) {
        return false;
      }
      ref = indices(variables);
      for (k = 0, len1 = ref.length; k < len1; k++) {
        i = ref[k];
        if (this.degrees[i] < that.degrees[i]) {
          return true;
        }
        if (this.degrees[i] > that.degrees[i]) {
          return false;
        }
      }
      return false;
    };

    Term.prototype.multiply = function(that) {
      var degrees;
      degrees = indices(variables).map((function(_this) {
        return function(i) {
          return _this.degrees[i] + that.degrees[i];
        };
      })(this));
      return new Term(degrees);
    };

    Term.prototype.divide = function(that) {
      var degrees;
      degrees = indices(variables).map((function(_this) {
        return function(i) {
          return _this.degrees[i] - that.degrees[i];
        };
      })(this));
      return new Term(degrees);
    };

    Term.prototype.gcd = function(that) {
      var degrees;
      degrees = indices(variables).map((function(_this) {
        return function(i) {
          return Math.min(_this.degrees[i], that.degrees[i]);
        };
      })(this));
      return new Term(degrees);
    };

    Term.prototype.hasOnly = function(i) {
      return indices(variables).filter((function(_this) {
        return function(j) {
          return j !== i;
        };
      })(this)).every((function(_this) {
        return function(j) {
          return _this.degrees[j] === 0;
        };
      })(this));
    };

    Term.one = function() {
      var degrees;
      degrees = indices(variables).map(function(i) {
        return 0;
      });
      return new Term(degrees);
    };

    Term.parse = function(input) {
      var degrees;
      degrees = indices(variables).map(function(i) {
        return 0;
      });
      input.split(/\s+/).forEach(function(str) {
        var i, match, n, x;
        match = str.match(/^(\w+)\^(\d+)$/);
        if (match) {
          x = match[1];
          n = Number(match[2]);
        } else {
          x = str;
          n = 1;
        }
        i = variables.indexOf(x);
        if (i === -1) {
          println("Illegal variable name: '" + x + "'");
          throw "In Term.parse";
        }
        return degrees[i] += n;
      });
      return new Term(degrees);
    };

    return Term;

  })();

  Monomial = (function() {
    function Monomial(coef, term) {
      this.coef = coef;
      this.term = term;
    }

    Monomial.prototype.toString = function() {
      if (this.coef === 1) {
        return "" + this.term;
      } else if (this.term.isOne()) {
        return "" + this.coef;
      } else {
        return this.coef + " " + this.term;
      }
    };

    Monomial.prototype.multiply = function(that) {
      return new Monomial(this.coef * that.coef, this.term.multiply(that.term));
    };

    Monomial.prototype.divide = function(that) {
      return new Monomial(this.coef / that.coef, this.term.divide(that.term));
    };

    Monomial.prototype.gcd = function(that) {
      return new Monomial(gcd(this.coef, that.coef), this.term.gcd(that.term));
    };

    Monomial.prototype.derivative = function(i) {
      var coef, degrees, term;
      coef = this.coef * this.term.degrees[i];
      degrees = indices(variables).map((function(_this) {
        return function(j) {
          return _this.term.degrees[j] - (j === i ? 1 : 0);
        };
      })(this));
      term = new Term(degrees);
      return new Monomial(coef, term);
    };

    Monomial.from = function(coef) {
      return new Monomial(coef, Term.one());
    };

    Monomial.parse = function(input) {
      var coef, match, term;
      match = input.match(/^-?\d+$/);
      if (match) {
        return Monomial.of(Number(input));
      }
      match = input.match(/^(-?\d+)\s+(.*)$/);
      if (match) {
        coef = Number(match[1]);
        term = Term.parse(match[2]);
      } else {
        coef = 1;
        term = Term.parse(input);
      }
      return new Monomial(coef, term);
    };

    return Monomial;

  })();

  Polynomial = (function() {
    function Polynomial(monomials) {
      var coef, term;
      this.monomials = [];
      monomials = sortBy(monomials, (function(_this) {
        return function(m1, m2) {
          return !m1.term.lessThan(m2.term);
        };
      })(this));
      while (monomials.length > 0) {
        coef = 0;
        term = monomials[0].term;
        while (monomials.length > 0 && monomials[0].term.equals(term)) {
          coef += monomials.shift().coef;
        }
        if (coef !== 0) {
          this.monomials.push(new Monomial(coef, term));
        }
      }
    }

    Polynomial.prototype.toString = function() {
      return this.monomials.map((function(_this) {
        return function(m) {
          return "" + m;
        };
      })(this)).join(" + ");
    };

    Polynomial.prototype.isZero = function() {
      return this.monomials.length === 0;
    };

    Polynomial.prototype.add = function(that) {
      return new Polynomial(this.monomials.concat(that.monomials));
    };

    Polynomial.prototype.subtract = function(that) {
      return this.add(that.multiply(Polynomial.from(Monomial.from(-1))));
    };

    Polynomial.prototype.multiply = function(that) {
      var monomials;
      monomials = concat(this.monomials.map((function(_this) {
        return function(m1) {
          return that.monomials.map(function(m2) {
            return m1.multiply(m2);
          });
        };
      })(this)));
      return new Polynomial(monomials);
    };

    Polynomial.prototype.derivative = function(i) {
      return new Polynomial(this.monomials.map((function(_this) {
        return function(m) {
          return m.derivative(i);
        };
      })(this)));
    };

    Polynomial.prototype.leading = function() {
      return this.monomials[0];
    };

    Polynomial.prototype.sPolynomial = function(that) {
      var g;
      if (this.isZero() || that.isZero()) {
        throw "In Polynomial.prototype.sPolynomial";
      }
      g = this.leading().gcd(that.leading());
      return this.multiply(Polynomial.from(that.leading().divide(g))).subtract(that.multiply(Polynomial.from(this.leading().divide(g))));
    };

    Polynomial.prototype.isReducibleBy = function(that) {
      if (this.isZero()) {
        return false;
      } else if (that.isZero()) {
        throw "In Polynomial.prototype.isReducibleBy";
      } else {
        return that.leading().term.divides(this.leading().term);
      }
    };

    Polynomial.prototype.reduce = function(that) {
      return this.sPolynomial(that);
    };

    Polynomial.prototype.reduceByList = function(those) {
      var k, len1, reduced, result, that;
      result = this;
      while (true) {
        reduced = false;
        for (k = 0, len1 = those.length; k < len1; k++) {
          that = those[k];
          if (result.isReducibleBy(that)) {
            result = result.reduce(that);
            reduced = true;
          }
        }
        if (!reduced) {
          return result;
        }
      }
    };

    Polynomial.from = function() {
      var monomials;
      monomials = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return new Polynomial(monomials);
    };

    Polynomial.parse = function(input) {
      var monomials;
      monomials = input.split(/\s*\+\s*/).map(Monomial.parse);
      return new Polynomial(monomials);
    };

    return Polynomial;

  })();

  indices = (function(_this) {
    return function(arr) {
      var k, ref, results;
      return (function() {
        results = [];
        for (var k = 0, ref = arr.length; 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--){ results.push(k); }
        return results;
      }).apply(this);
    };
  })(this);

  concat = (function(_this) {
    return function(arrs) {
      var ref;
      return (ref = []).concat.apply(ref, arrs);
    };
  })(this);

  gcd = (function(_this) {
    return function(x, y) {
      var r;
      while (y !== 0) {
        r = x % y;
        x = y;
        y = r;
      }
      return x;
    };
  })(this);

  sortBy = (function(_this) {
    return function(arr, rel) {
      var i, j, k, l, len, len1, o, ref, ref1, ref2, results;
      arr = arr.slice();
      len = arr.length;
      ref = (function() {
        results = [];
        for (var l = 0; 0 <= len ? l < len : l > len; 0 <= len ? l++ : l--){ results.push(l); }
        return results;
      }).apply(this).reverse();
      for (k = 0, len1 = ref.length; k < len1; k++) {
        i = ref[k];
        for (j = o = 0, ref1 = i; 0 <= ref1 ? o < ref1 : o > ref1; j = 0 <= ref1 ? ++o : --o) {
          if (!rel(arr[j], arr[j + 1])) {
            ref2 = [arr[j + 1], arr[j]], arr[j] = ref2[0], arr[j + 1] = ref2[1];
          }
        }
      }
      return arr;
    };
  })(this);

  computeGrobnerBasis = (function(_this) {
    return function(fs) {
      var added, k, len1, ref, s;
      fs = fs.filter(function(f) {
        return !f.isZero();
      });
      while (true) {
        added = false;
        ref = allSPolynomials(fs);
        for (k = 0, len1 = ref.length; k < len1; k++) {
          s = ref[k];
          s = s.reduceByList(fs);
          if (!s.isZero()) {
            fs.push(s);
            added = true;
          }
        }
        if (!added) {
          return fs;
        }
      }
    };
  })(this);

  allSPolynomials = (function(_this) {
    return function(fs) {
      var k, len, results;
      len = fs.length;
      return concat((function() {
        results = [];
        for (var k = 0; 0 <= len ? k < len : k > len; 0 <= len ? k++ : k--){ results.push(k); }
        return results;
      }).apply(this).map(function(i) {
        var k, ref, results;
        return (function() {
          results = [];
          for (var k = ref = i + 1; ref <= len ? k < len : k > len; ref <= len ? k++ : k--){ results.push(k); }
          return results;
        }).apply(this).map(function(j) {
          return fs[i].sPolynomial(fs[j]);
        });
      }));
    };
  })(this);

  basisOfQuotient = (function(_this) {
    return function(generators) {
      var allTerms, error, error1, upperBound;
      try {
        upperBound = indices(variables).map(function(i) {
          return generators.filter(function(generator) {
            return generator.hasOnly(i);
          }).map(function(generator) {
            return generator.degrees[i];
          }).reduce(Math.min);
        });
      } catch (error1) {
        error = error1;
        return "Infinity";
      }
      allTerms = latticePointUnder(upperBound).map(function(lp) {
        return new Term(lp);
      });
      return generators.reduce((function(terms, generator) {
        return terms.filter(function(term) {
          return !generator.divides(term);
        });
      }), allTerms);
    };
  })(this);

  latticePointUnder = (function(_this) {
    return function(upperBound) {
      var head, k, lps, results, tail;
      if (upperBound.length === 0) {
        return [[]];
      }
      head = upperBound[0], tail = 2 <= upperBound.length ? slice.call(upperBound, 1) : [];
      lps = latticePointUnder(tail);
      return concat((function() {
        results = [];
        for (var k = 0; 0 <= head ? k < head : k > head; 0 <= head ? k++ : k--){ results.push(k); }
        return results;
      }).apply(this).map(function(i) {
        return lps.map(function(lp) {
          return [i].concat(lp);
        });
      }));
    };
  })(this);

  println = (function(_this) {
    return function(mess) {
      var stdout;
      if (mess == null) {
        mess = "";
      }
      stdout = document.getElementById("stdout");
      stdout.appendChild(document.createTextNode(mess));
      stdout.appendChild(document.createElement("br"));
      return stdout.scrollTop = stdout.scrollHeight;
    };
  })(this);

  getValue = (function(_this) {
    return function(id) {
      return document.getElementById(id).value;
    };
  })(this);

  setValue = (function(_this) {
    return function(id, value) {
      return document.getElementById(id).value = value;
    };
  })(this);

  setEnable = (function(_this) {
    return function(id) {
      return document.getElementById(id).disabled = false;
    };
  })(this);

  setDisable = (function(_this) {
    return function(id) {
      return document.getElementById(id).disabled = true;
    };
  })(this);

  doSequentially = (function(_this) {
    return function(fns) {
      var head, tail;
      if (fns.length === 0) {
        return;
      }
      head = fns[0], tail = 2 <= fns.length ? slice.call(fns, 1) : [];
      head();
      return setTimeout(function() {
        return doSequentially(tail);
      });
    };
  })(this);

  onclick = (function(_this) {
    return function() {
      var basis, dfs, f, lts, mu, qbasis;
      f = dfs = basis = lts = qbasis = mu = null;
      return doSequentially([
        function() {
          ["variables", "f", "compute"].forEach(setDisable);
          return println("Start!");
        }, function() {
          variables = getValue("variables").split(/\s+/);
          return println("variables: " + variables);
        }, function() {
          f = Polynomial.parse(getValue("f"));
          return println("f = " + f);
        }, function() {
          dfs = indices(variables).map(function(i) {
            return f.derivative(i);
          });
          return indices(variables).forEach(function(i) {
            return println("f_" + variables[i] + " = " + dfs[i]);
          });
        }, function() {
          var g, k, len1;
          basis = computeGrobnerBasis(dfs);
          println("Grobner basis: {");
          for (k = 0, len1 = basis.length; k < len1; k++) {
            g = basis[k];
            println("> " + g);
          }
          return println("> }");
        }, function() {
          var k, len1, term;
          lts = basis.map(function(g) {
            return g.leading().term;
          });
          println("leading terms: {");
          for (k = 0, len1 = lts.length; k < len1; k++) {
            term = lts[k];
            println("> " + term);
          }
          return println("> }");
        }, function() {
          qbasis = basisOfQuotient(lts);
          if (qbasis === "Infinity") {
            mu = "Infinity";
          } else {
            println("basis of quotient: {");
            qbasis.forEach(function(term) {
              return println("> " + term);
            });
            println("> }");
            mu = qbasis.length;
          }
          println("Milnor Number: " + mu);
          return setValue("mu", mu);
        }, function() {
          ["variables", "f", "compute"].forEach(setEnable);
          println("Finish!");
          return println();
        }
      ]);
    };
  })(this);

  main = (function(_this) {
    return function() {
      setValue("variables", "x y");
      setValue("f", "x^3 + -1 x y^2");
      setValue("mu", "");
      ["variables", "f", "compute"].forEach(setEnable);
      return document.getElementById("compute").onclick = onclick;
    };
  })(this);

  main();

}).call(this);
