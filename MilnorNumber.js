// Generated by CoffeeScript 1.10.0
(function() {
  var Monomial, Polynomial, Term, gcd, getValue, gridsUnder, grobner, milnorNumber, println, setDisabled, setValue, sortBy, variableNames, variables,
    slice = [].slice;

  getValue = function(id) {
    return document.getElementById(id).value;
  };

  setValue = function(id, value) {
    return document.getElementById(id).value = value;
  };

  setDisabled = function(id, value) {
    if (value == null) {
      value = true;
    }
    return document.getElementById(id).disabled = value;
  };

  println = function(mess) {
    var stdout;
    if (mess == null) {
      mess = "";
    }
    stdout = document.getElementById("stdout");
    stdout.appendChild(document.createTextNode(mess));
    stdout.appendChild(document.createElement("br"));
    stdout.scrollTop = stdout.scrollHeight;
    return mess;
  };

  sortBy = function(arr, rel) {
    var i, j, k, l, len, n, ref, ref1, ref2, ref3, results;
    ref1 = (function() {
      results = [];
      for (var l = 0, ref = arr.length; 0 <= ref ? l < ref : l > ref; 0 <= ref ? l++ : l--){ results.push(l); }
      return results;
    }).apply(this).reverse();
    for (k = 0, len = ref1.length; k < len; k++) {
      i = ref1[k];
      for (j = n = 0, ref2 = i; 0 <= ref2 ? n < ref2 : n > ref2; j = 0 <= ref2 ? ++n : --n) {
        if (!rel(arr[j], arr[j + 1])) {
          ref3 = [arr[j + 1], arr[j]], arr[j] = ref3[0], arr[j + 1] = ref3[1];
        }
      }
    }
    return arr;
  };

  gcd = function(x, y) {
    var r;
    while (y !== 0) {
      r = x % y;
      x = y;
      y = r;
    }
    return x;
  };

  variables = [];

  variableNames = [];

  Term = (function() {
    Term.one = function() {
      return new Term(variables.map(function() {
        return 0;
      }));
    };

    function Term(indices) {
      this.indices = indices;
    }

    Term.prototype.toString = function() {
      var indices;
      if (this.isOne()) {
        return "1";
      } else {
        indices = this.indices;
        return variables.filter(function(i) {
          return indices[i] !== 0;
        }).map(function(i) {
          if (indices[i] === 1) {
            return "" + variableNames[i];
          } else {
            return variableNames[i] + "^" + indices[i];
          }
        }).join(" ");
      }
    };

    Term.prototype.isOne = function() {
      var index, k, len, ref;
      ref = this.indices;
      for (k = 0, len = ref.length; k < len; k++) {
        index = ref[k];
        if (index !== 0) {
          return false;
        }
      }
      return true;
    };

    Term.prototype.lexle = function(that) {
      var i, k, len;
      for (k = 0, len = variables.length; k < len; k++) {
        i = variables[k];
        if (this.indices[i] < that.indices[i]) {
          return true;
        }
        if (this.indices[i] > that.indices[i]) {
          return false;
        }
      }
      return true;
    };

    Term.prototype.equiv = function(that) {
      return this.lexle(that) && that.lexle(this);
    };

    Term.prototype.divides = function(that) {
      var i, k, len;
      for (k = 0, len = variables.length; k < len; k++) {
        i = variables[k];
        if (this.indices[i] > that.indices[i]) {
          return false;
        }
      }
      return true;
    };

    Term.prototype.hasOnly = function(i0) {
      var i, k, len;
      for (k = 0, len = variables.length; k < len; k++) {
        i = variables[k];
        if (i !== i0 && this.indices[i] !== 0) {
          return false;
        }
      }
      return true;
    };

    return Term;

  })();

  Monomial = (function() {
    Monomial.parse = function(str) {
      var c, cstr, i, index, indices, indstr, k, len, ref, ref1, x, xistr, xistrs;
      ref = str.split(/\s+/), cstr = ref[0], xistrs = 2 <= ref.length ? slice.call(ref, 1) : [];
      c = Number(cstr);
      indices = variables.map(function() {
        return 0;
      });
      for (k = 0, len = xistrs.length; k < len; k++) {
        xistr = xistrs[k];
        ref1 = xistr.split("^"), x = ref1[0], indstr = ref1[1];
        i = variableNames.indexOf(x);
        if (i === -1) {
          throw "illegal variable name";
        }
        index = indstr != null ? Number(indstr) : 1;
        indices[i] += index;
      }
      return new Monomial(c, new Term(indices));
    };

    Monomial.from = function(c) {
      return new Monomial(c, Term.one());
    };

    function Monomial(coefficient, term) {
      this.coefficient = coefficient;
      this.term = term;
    }

    Monomial.prototype.toString = function() {
      if (this.term.isOne()) {
        return "" + this.coefficient;
      } else {
        return this.coefficient + " " + this.term;
      }
    };

    Monomial.prototype.derivative = function(i) {
      var indices;
      indices = this.term.indices.slice();
      indices[i] -= 1;
      return new Monomial(this.coefficient * this.term.indices[i], new Term(indices));
    };

    Monomial.prototype.gcd = function(m2) {
      var c, indices, m1;
      m1 = this;
      c = gcd(m1.coefficient, m2.coefficient);
      indices = variables.map(function(i) {
        return Math.min(m1.term.indices[i], m2.term.indices[i]);
      });
      return new Monomial(c, new Term(indices));
    };

    Monomial.prototype.times = function(m2) {
      var indices, m1;
      m1 = this;
      indices = variables.map(function(i) {
        return m1.term.indices[i] + m2.term.indices[i];
      });
      return new Monomial(m1.coefficient * m2.coefficient, new Term(indices));
    };

    Monomial.prototype.divide = function(m2) {
      var indices, m1;
      m1 = this;
      indices = variables.map(function(i) {
        return m1.term.indices[i] - m2.term.indices[i];
      });
      return new Monomial(m1.coefficient / m2.coefficient, new Term(indices));
    };

    return Monomial;

  })();

  Polynomial = (function() {
    Polynomial.parse = function(str) {
      return new Polynomial(str.split(/\s*\+\s*/).map(Monomial.parse));
    };

    Polynomial.zero = function() {
      return new Polynomial([]);
    };

    function Polynomial(monomials) {
      var coefficient, term;
      this.monomials = [];
      monomials = monomials.slice();
      sortBy(monomials, function(m1, m2) {
        return m2.term.lexle(m1.term);
      });
      while (monomials.length > 0) {
        coefficient = 0;
        term = monomials[0].term;
        while (monomials.length > 0 && monomials[0].term.equiv(term)) {
          coefficient += monomials.shift().coefficient;
        }
        if (coefficient !== 0) {
          this.monomials.push(new Monomial(coefficient, term));
        }
      }
    }

    Polynomial.prototype.toString = function() {
      if (this.isZero()) {
        return "0";
      } else {
        return this.monomials.map(function(m) {
          return m.toString();
        }).join(" + ");
      }
    };

    Polynomial.prototype.isZero = function() {
      return this.monomials.length === 0;
    };

    Polynomial.prototype.derivative = function(i) {
      return new Polynomial(this.monomials.map(function(m) {
        return m.derivative(i);
      }));
    };

    Polynomial.prototype.spolynomial = function(f2) {
      var f1, g, q1, q2;
      f1 = this;
      if (f1.isZero() || f2.isZero()) {
        return Polynomial.zero();
      }
      g = f1.leading().gcd(f2.leading());
      q1 = f1.leading().divide(g);
      q2 = f2.leading().divide(g);
      return f1.times(q2).subtract(f2.times(q1));
    };

    Polynomial.prototype.leading = function() {
      return this.monomials[0];
    };

    Polynomial.prototype.times = function(that) {
      var k, l, len, len1, m1, m2, monomials, ref, ref1;
      if (that instanceof Monomial) {
        that = new Polynomial([that]);
      }
      monomials = [];
      ref = this.monomials;
      for (k = 0, len = ref.length; k < len; k++) {
        m1 = ref[k];
        ref1 = that.monomials;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          m2 = ref1[l];
          monomials.push(m1.times(m2));
        }
      }
      return new Polynomial(monomials);
    };

    Polynomial.prototype.add = function(that) {
      return new Polynomial(this.monomials.concat(that.monomials));
    };

    Polynomial.prototype.subtract = function(that) {
      return this.add(that.times(Monomial.from(-1)));
    };

    Polynomial.prototype.reduce = function(f2) {
      var f1, g, l1, l2;
      f1 = this;
      if (f2.isZero()) {
        throw "Polynomial#reduce: divide by zero";
      }
      l2 = f2.leading();
      while (true) {
        if (f1.isZero()) {
          return f1;
        }
        l1 = f1.leading();
        if (!l2.term.divides(l1.term)) {
          return f1;
        }
        g = l1.gcd(l2);
        f1 = f1.times(l2.divide(g)).subtract(f2.times(l1.divide(g)));
      }
    };

    return Polynomial;

  })();

  grobner = function(fs) {
    var basis, f, gs, i, j, k, l, len, n, ref, ref1, ref2, s;
    basis = fs.slice();
    while (true) {
      gs = [];
      for (i = k = 0, ref = basis.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        for (j = l = ref1 = i + 1, ref2 = basis.length; ref1 <= ref2 ? l < ref2 : l > ref2; j = ref1 <= ref2 ? ++l : --l) {
          s = basis[i].spolynomial(basis[j]);
          for (n = 0, len = basis.length; n < len; n++) {
            f = basis[n];
            s = s.reduce(f);
          }
          if (!s.isZero()) {
            gs.push(s);
          }
        }
      }
      if (gs.length === 0) {
        return basis;
      }
      basis = basis.concat(gs);
    }
    return sortBy(basis, function(f1, f2) {
      return f1.leading().term.lexle(f2.leading().term);
    });
  };

  milnorNumber = function(terms) {
    var gs, k, len, limits, term, ts;
    limits = variables.map(function(i0) {
      var found, k, len, min, term;
      found = false;
      min;
      for (k = 0, len = terms.length; k < len; k++) {
        term = terms[k];
        if (term.hasOnly(i0) && ((typeof min === "undefined" || min === null) || min > term.indices[i0])) {
          min = term.indices[i0];
        }
      }
      return min;
    });
    println("limits: " + limits);
    gs = gridsUnder(limits);
    ts = gs.map(function(g) {
      return new Term(g);
    });
    for (k = 0, len = terms.length; k < len; k++) {
      term = terms[k];
      ts = ts.filter(function(t) {
        return !term.divides(t);
      });
    }
    return ts.length;
  };

  gridsUnder = function(limits) {
    var gs, k, limit, limits_, ref, results;
    if (limits.length === 0) {
      return [[]];
    } else {
      limit = limits[0], limits_ = 2 <= limits.length ? slice.call(limits, 1) : [];
      gs = gridsUnder(limits_);
      return (ref = []).concat.apply(ref, (function() {
        results = [];
        for (var k = 0; 0 <= limit ? k < limit : k > limit; 0 <= limit ? k++ : k--){ results.push(k); }
        return results;
      }).apply(this).map(function(i) {
        return gs.map(function(g) {
          return [i].concat(g);
        });
      }));
    }
  };

  setDisabled("variables", false);

  setValue("variables", "x y");

  setDisabled("f", false);

  setValue("f", "1 x^3 + 1 x y^2");

  setDisabled("compute", false);

  document.getElementById("compute").addEventListener("click", function() {
    println("start!");
    setDisabled("variables");
    setDisabled("f");
    setDisabled("compute");
    setValue("mu", "");
    return setTimeout(function() {
      var basis, dfs, f, k, lts, mu, ref, results;
      variableNames = getValue("variables").split(/\s+/);
      variables = (function() {
        results = [];
        for (var k = 0, ref = variableNames.length; 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--){ results.push(k); }
        return results;
      }).apply(this);
      println("variables: " + variableNames);
      f = Polynomial.parse(getValue("f"));
      println("f: " + f);
      dfs = variables.map(function(i) {
        return f.derivative(i);
      });
      println("dfs: " + dfs);
      basis = grobner(dfs);
      println("basis: " + basis);
      lts = basis.map(function(f) {
        return f.leading().term;
      });
      println("lts: " + lts);
      mu = milnorNumber(lts);
      println("mu: " + mu);
      setValue("mu", mu);
      println("finish!");
      setDisabled("variables", false);
      setDisabled("f", false);
      return setDisabled("compute", false);
    });
  });

}).call(this);
